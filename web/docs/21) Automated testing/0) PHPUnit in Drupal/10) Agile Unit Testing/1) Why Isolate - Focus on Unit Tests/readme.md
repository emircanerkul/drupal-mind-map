Most objects of a system depend on other objects (depended-on objects). Objects contain other objects and delegate work to them. When unit testing one object the decision is up to the developer to touch the depended-on object with the same unit test or substitute the depended-on object with an alternative object ([test double](https://phpunit.readthedocs.io/en/9.5/test-doubles.html)).  
The motivations to substitute (isolate) depended-on objects with test double are many-fold and have to be contrasted with the motivations against it.

### Motivations for isolation

Motivations for isolation (concrete depended-on objects are substituted with test doubles) are:

* **Simulate hard to test behaviour** If the object under test contains behaviour that is hard to simulate in a unit testing environment (i.e. specific error conditions, or asynchronous events), a substituted test double could simulate it and could allow more test scenarios and faster test runs.
* **Granular defect localization** If an implementation changes and a test flags up an unexpected result, it is easy to localize the defect if the object under test is isolated from its environment.
* **No triggering of unwanted behaviour** Without any isolation, the behaviour of the object under test might trigger behaviour on the depended-on object that causes other unexpected effects in unit tests. By substituting the depended-on object, the behaviour the object under test triggers is controlled.
* **Less setup code to satisfy dependencies of depended-on objects** Without any isolation, depended-on objects might require further dependencies in order to execute without errors. These dependencies would need to be satisfied by the unit test, increasing the knowledge of the unit test unnecessarily. Would the object under test use test doubles instead of concrete depended-on objects, the test doubles can be designed not to require further dependencies, reducing setup code and making the test easier to read and maintain.
* **Higher coverage through testing interactions** In order to test how an object under test interacts with depended-on objects, the unit test needs access to the depended-on objects. Test doubles can be designed to offer flexibility on how unit tests can observe the interaction with their object under test (mocks). Depended-on objects are often not designed for it, and developers are in danger of sacrificing the encapsulation of a concrete implementation of a depended-on object.
* **Code coverage numbers are more significant** When concrete depended-on objects are substituted, they don't get coverage through unit tests that focus on other objects. Code coverage tools can easier identify the need for additional tests of the concrete depended-on objects when no code coverage on concrete depended-on objects has been registered via other unit tests.

### Motivations against isolation

When concrete depended-on objects are executed by the object under test, then isolation is not performed and the motivations against isolation can be:

* **Over-specified unit tests hinder refactorings** If all interactions with depended-on objects are tested, refactorings on objects under test that change any of the interactions also need to change the unit tests and this increases the overall effort of refactorings. To counter this danger, unit tests should only focus to test one piece of behaviour and not repeat tests of other tests and not test interactions that are not significant.
* **More difficult to write and read unit tests** If the object under test has to create test doubles for all its depended-on objects, it increases the size of the unit test and makes it more difficult to read. However, automatic test double creation libraries such as Mockery or PHPUnit ease the time it takes to write test doubles.
* **Higher code coverage with fewer tests** While objects under test might not be able to and want to test all interactions with depended-on objects, they automatically cover some behaviour of depended-on objects and can achieve a higher code coverage with fewer tests. However, the higher code coverage through unit tests that triggered code of depended-on objects might lead to a false sense of security as the focus of the unit test was not on the depended-on object but on the object under test.
* **The danger of substituting behaviour to test** When isolating too many developers might accidentally substitute objects they actually would want to test and the risk of integration increases. Watch code coverage results to ensure behaviour continues to be tested. The more depended-on objects the unit test touches, the more it steers testing efforts away from unit testing towards functional testing. At some point, different tooling than unit testing frameworks, additional qualified personnel such as Quality Engineers and separate test runners are more appropriate for complete functional and black box testing (See Agile Functional Testing).